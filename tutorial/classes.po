# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-03-14 12:51+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: tutorial/classes.rst:5
msgid "Classes"
msgstr "Κλάσεις"

#: tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Οι κλάσεις παρέχουν ένα μέσο ομαδοποίησης δεδομένων και λειτουργικότητας. "
"Η δημιουργία μιας νέας κλάσης δημιουργεί έναν νέο *τύπο* αντικειμένου, επιτρέποντας νέα "
"*στιγμιότυπα* αυτού του τύπου που πρόκειται να γίνουν. Κάθε στιγμιότυπο κλάσης μπορεί να έχει "
"χαρακτηριστικά που συνδέονται με αυτό για τη διατήρηση της κατάστασής του. Τα στιγμιότυπα κλάσης μπορούν "
"να έχουν επίσης μεθόδους (που ορίζονται από την κλάση του) για την τροποποίηση της κατάστασής του."

#: tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Σε σύγκριση με άλλες γλώσσες προγραμματισμού, ο μηχανισμός κλάσης της Python προσθέτει "
"κλάσεις με ελάχιστο νέο συντακτικό και σημασιολογία. Είναι ένα μείγμα των "
"μηχανισμών κλάσεων που βρέθηκαν στη C++ και στο Modula-3. Οι κλάσεις της Python παρέχουν όλα τα "
"standard χαρακτηριστικά του Αντικειμενοστραφούς Προγραμματισμού: ο μηχανισμός της κληρονομικότητας της κλάσης "
"επιτρέπει την ύπαρξη πολλαπλών βασικών κλάσεων, μια παραγόμενη κλάση να μπορεί να παρακάμψει οποιεσδήποτε "
"μεθόδους της βασικής κλάσης ή κλάσεων, και μια μέθοδος να μπορεί να καλέσει τη μέθοδο μίας "
"βασικής κλάσης με το ίδιο όνομα. Τα αντικείμενα μπορούν να περιέχουν αυθαίρετα ποσά και "
"είδη δεδομένων. Όπως ισχύει για τα modules, οι κλάσεις συμμετέχουν στη δυναμική "
"φύση της Python: δημιουργούνται κατά το χρόνο εκτέλεσης και μπορούν να τροποποιηθούν περαιτέρω "
"μετά τη δημιουργία. "

#: tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Στην ορολογία της C++, συνήθως τα μέλη της κλάσης (συμπεριλαμβανομένων των μελών δεδομένων) είναι "
"*δημόσια* (εκτός από βλέπε παρακάτω :ref:`tut-private`), και όλες οι συμμετέχουσες συναρτήσεις είναι "
"*εικονικές*. Όπως και στο Modula-3, δεν υπάρχουν συντομογραφίες για την αναφορά στα "
"μέλη του αντικειμένου από τις μεθόδους του: η μέθοδος δηλώνεται με "
"ρητό πρώτο όρισμα που αντιπροσωπεύει το αντικείμενο, το οποίο παρέχεται "
"έμμεσα από την κλήση. Όπως και στο Smalltalk, οι ίδιες οι κλάσεις είναι αντικείμενα."
"Αυτό παρέχει σημασιολογία για εισαγωγή και μετονομασία. Σε αντίθεση με τις γλώσσες C++ και "
"Modula-3, οι built-in τύποι μπορούν να χρησιμοποιηθούν ως βασικές κλάσεις για επέκταση από τον "
"χρήστη. Επίσης, όπως στην C++, οι περισσότεροι built-in τελεστές με ειδική σύνταξη "
"(αριθμητικοί τελεστές, εγγραφή κ.λπ.) μπορούν να επαναπροσδιοριστούν για τα στιγμιότυπα "
"κλάσης."

#: tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Ελλείψει καθολικής αποδεκτής ορολογίας για να μιλήσω για τις κλάσεις, θα κάνω "
"περιστασιακή χρήση όρων από τη Smalltalk και τη C++. Θα χρησιμοποιούσα όρους  από τη Modula-3, "
"καθώς η αντικειμενοστραφής σημασιολογία του είναι πιο κοντά σε αυτήν της Python από ότι της C++, "
"Αλλά πιστεύω ότι λίγοι αναγνώστες το έχουν ακούσει.) "

#: tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Λίγα λόγια για Ονόματα και Αντικείμενα"

#: tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Τα αντικείμενα έχουν μοναδικότητα και πολλά ονόματα (σε πολλαπλά πεδία) μπορούν να "
"συνδεθούν στο ίδιο αντικείμενο. Αυτό είναι γνωστό ως ψευδώνυμο σε άλλες γλώσσες."
"Αυτό συνήθως δεν εκτιμάται με μια πρώτη ματιά στην Python και μπορεί να "
"αγνοείται με ασφάλεια όταν ασχολείται με αμετάβλητους βασικούς τύπους (αριθμοί, συμβολοσειρές, "
"πλειάδες (tuples)). Ωστόσο, το ψευδώνυμο έχει μια πιθανώς εκπληκτική επίδραση στη "
"σημασιολογία του κώδικα της Python που περιλαμβάνει ευμετάβλητα αντικείμενα όπως λίστες, "
"λεξικά, και τους περισσότερους άλλους τύπους. Αυτό χρησιμοποιείται συνήθως προς όφελος του "
"προγράμματος, δεδομένου ότι τα ψευδώνυμα συμπεριφέρονται σαν δείκτες από ορισμένες απόψεις. "
"Για παράδειγμα, η μετάδοση ενός αντικειμένου είναι ανέξοδη αφού μόνο ένας δείκτης περνά από την "
"υλοποίηση, και αν μια συνάρτηση τροποποιεί ένα αντικείμενο που έχει περάσει ως όρισμα, "
"ο καλών θα δει την αλλαγή --- αυτό εξαλείφει την ανάγκη για δύο "
"διαφορετικούς μηχανισμούς μετάδοσης ορισμάτων όπως στην Pascal."

#: tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Εμβέλεια και Πεδία Ονομάτων στην Python"

#: tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Πριν από την εισαγωγή των κλάσεων, πρέπει πρώτα να σας πω κάτι για τους "
"κανόνες εμβέλειας της Python. Οι ορισμοί των κλάσεων παίζουν μερικά ξεκάθαρα κόλπα με τα "
"πεδία ονομάτων και πρέπει να γνωρίζετε πώς λειτουργούν πλήρως τα πεδία ονομάτων και η εμβέλεια "
"για να κατανοήσετε πλήρως τι συμβαίνει. Παρεμπιπτόντως, η γνώση για αυτό το θέμα είναι "
"χρήσιμη για κάθε προχωρημένο προγραμματιστή της Python."

#: tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Ας ξεκινήσουμε με ορισμένους ορισμούς. "

#: tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Ένας *πεδίο ονομάτων (namespace)* είναι μια αντιστοίχιση από ονόματα σε αντικείμενα. Τα περισσότερα πεδία ονομάτων υλοποιούνται "
"επί του παρόντος ως λεξικά Python, αλλά αυτό συνήθως δεν γίνεται "
"αντιληπτό με κανέναν τρόπο (εκτός από την απόδοση) και μπορεί να αλλάξει στο "
"μέλλον. Παραδείγματα πεδίων ονομάτων είναι: το σύνολο των ενσωματωμένων ονομάτων (που περιέχει "
"συναρτήσεις όπως :func:`abs` και ενσωματωμένα ονόματα εξαιρέσεων)∙ τα καθολικά "
"ονόματα σε ένα module και τα τοπικά ονόματα σε μια επίκληση συνάρτησης. Κατά μία έννοια "
"το σύνολο των χαρακτηριστικών ενός αντικειμένου σχηματίζει επίσης ένα πεδίο ονομάτων. Το σημαντικό "
"πράγμα που πρέπει να γνωρίζετε για τα πεδία ονομάτων είναι ότι δεν υπάρχει καμία απολύτως σχέση "
"μεταξύ ονομάτων σε διαφορετικά πεδία ονομάτων, για παράδειγμα, δύο διαφορετικά modules "
"μπορεί και τα δύο να ορίσουν μια συνάρτηση ``maximize`` χωρίς σύγχυση --- χρήστες των "
"modules πρέπει να την προσθέσουν με το όνομα του module."

#: tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"Παρεμπιπτόντως, χρησιμοποιώ τη λέξη *attribute* για οποιοδήποτε όνομα που ακολουθεί μια τελεία --- για "
"παράδειγμα, στην έκφραση ``z.real``, το ``real`` είναι ένα attribute του "
"αντικειμένου ``z``. Αυστηρά μιλώντας, οι αναφορές σε ονόματα των modules είναι "
"αναφορές σε attributes: στην έκφραση ``modname.funcname``, το ``modname`` είναι "
"ένα module αντικείμενο  και το ``funcname`` είναι ένα attribute του αντικειμένου. Σε αυτήν την περίπτωση συμβαίνει να "
"υπάρχει μια απλή αντιστοίχιση μεταξύ των attributes των modules και "
"των καθολικών ονομάτων που ορίζονται στο module: μοιράζονται τον ίδιο χώρο ονομάτων! [#]_"

#: tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"Τα attributes μπορεί να είναι μόνο για ανάγνωση ή εγγράψιμα. Στην τελευταία περίπτωση, είναι δυνατή η ανάθεση "
"attributes. Τα attributes των modules είναι εγγράψιμα: μπορείτε να γράψετε "
"``modname.the_answer = 42``. Τα εγγράψιμα attributes μπορούν επίσης να διαγραφούν με "
"την δήλωση :keyword:`del`. Για παράδειγμα, ``del modname.the_answer`` θα "
"αφαιρέσει το attribute :attr:`!the_answer` από το αντικείμενο που ονομάστηκε από το "
"``modname``."

#: tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Οι χώροι ονομάτων δημιουργούνται σε διαφορετικές στιγμές και έχουν διαφορετική διάρκεια ζωής."
"Ο χώρος ονομάτων που περιέχει τα built-in ονόματα δημιουργείται κατά την εκκίνηση του διερμηνέα "
"της Python και δεν διαγράφεται ποτέ. Ο καθολικός χώρος ονομάτων για ένα "
"module δημιουργείται όταν διαβάζεται ο ορισμός του module. Κανονικά, οι χώροι ονομάτων "
"των modules διαρκούν επίσης μέχρι να τερματιστεί ο διερμηνέας. Οι δηλώσεις που εκτελούνται "
"από την επίκληση ανώτατου επιπέδου του διερμηνέα, είτε διαβάζονται από ένα script "
"είτε διαδραστικά, θεωρούνται μέρος ενός module που ονομάζεται :mod:"
"`__main__`, επομένως έχουν τον δικό τους καθολικό χώρο ονομάτων. (Τα ενσωματωμένα ονόματα "
"στην πραγματικότητα υπάρχουν επίσης σε ένα module,αυτό ονομάζεται :mod:`builtins`.)"

#: tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"Ο τοπικός χώρος ονομάτων για μια συνάρτηση δημιουργείται όταν καλείται η συνάρτηση, "
"και διαγράφεται όταν η συνάρτηση επιστρέφει ή δημιουργεί μια εξαίρεση που δεν "
"αντιμετωπίζεται στην συνάρτηση. (Στην πραγματικότητα, η λήθη θα ήταν καλύτερος τρόπος για να "
"περιγράψουμε τι πραγματικά συμβαίνει.) Φυσικά, οι επαναλαμβανόμενες επικλήσεις έχουν "
"το δικό τους τοπικό χώρο ονομάτων."

#: tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Η εμβέλεια είναι μια περιοχή κειμένου ενός προγράμματος Python όπου ένας χώρος ονομάτων είναι "
"άμεσα προσβάσιμος. Το \`Άμεση πρόσβαση\` εδώ σημαίνει ότι μια ανεπιφύλακτη "
"αναφορά σε ένα όνομα προσπαθεί να βρει το όνομα στον χώρο ονομάτων."

#: tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Παρόλο που τα πεδία προσδιορίζονται στατικά, χρησιμοποιούνται δυναμικά. Σε οποιοδήποτε "
"χρόνο κατά την διάρκεια της εκτέλεσης, υπάρχουν 3 ή 4 ένθετα πεδία των οποίων οι χώροι ονομάτων είναι "
"άμεσα προσβάσιμοι "

#: tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "η ενδότερη εμβέλεια, η οποία αναζητείται πρώτα, περιέχει τα τοπικά ονόματα"

#: tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"η εμβέλεια οποιωνδήποτε εσωκλειόμενων συναρτήσεων, τα οποία αναζητούνται ξεκινώντας από την "
"πλησιέστερη εσωκλειόμενη εμβέλεια, περιέχει μη τοπικά, αλλά και μη καθολικά ονόματα"

#: tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "η επόμενη προς την τελευταία εμβέλεια περιέχει τα τρέχοντα καθολικά ονόματα του module "

#: tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr "η πιο απομακρυσμένη εμβέλεια (που έγινε τελευταία αναζήτηση) είναι ο χώρος ονομάτων που περιέχει built-in ονόματα"

#: tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Εάν ένα όνομα έχει δηλωθεί ως καθολικό, τότε όλες οι αναφορές και οι εκχωρήσεις πηγαίνουν "
"απευθείας στο επόμενο προς το τελευταίο πεδίο που περιέχει τα καθολικά ονόματα του module. Για την "
"επανασύνδεση μεταβλητών που βρίσκονται εκτός της ενδότερης εμβέλειας ,μπορεί να χρησιμοποιηθεί η δήλωση του :keyword:"
"`nonlocal` . Εάν δεν δηλωθούν ως μη τοπικές, αυτές οι μεταβλητές "
"είναι μόνο για ανάγνωση (μια προσπάθεια εγγραφής σε μια τέτοια μεταβλητή θα δημιουργήσει απλώς μια "
"*νέα* τοπική μεταβλητή στην ενδότερη εμβέλεια, αφήνοντας αμετάβλητη την "
"εξωτερική μεταβλητή με το ίδιο όνομα )."

#: tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Συνήθως, η τοπική εμβέλεια παραπέμπει στα τοπικά ονόματα της (κείμενης) "
"τρέχουσας συνάρτησης. Εκτός συναρτήσεων, η τοπική εμβέλεια αναφέρεται στον ίδιο "
"χώρο ονομάτων με την καθολική εμβέλεια: τον χώρο ονομάτων του module.Οι ορισμοί κλάσεων "
"τοποθετούν έναν ακόμη χώρο ονομάτων στην τοπική εμβέλεια. "

#: tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Είναι σημαντικό να συνειδητοποιήσουμε ότι οι εμβέλειες καθορίζονται με κείμενο: η καθολική "
"εμβέλεια μιας συνάρτησης που ορίζεται σε ένα module είναι ο χώρος ονομάτων αυτού του module "
"ανεξάρτητα από το πού ή με ποιο ψευδώνυμο καλείται η συνάρτηση. Από την άλλη "
"πλευρά, η πραγματική αναζήτηση ονομάτων γίνεται δυναμικά, κατά το χρόνο εκτέλεσης --- "
"ωστόσο, ο ορισμός της γλώσσας εξελίσσεται προς τη στατική ανάλυση ονομάτων, "
"την ώρα της \`μεταγλώττισης\`, επομένως μην βασίζεστε σε δυναμική ανάλυση ονόματος! (Στην πραγματικότητα, "
"οι τοπικές μεταβλητές έχουν ήδη καθοριστεί στατικά.) "

#: tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Μια ιδιαίτερη ιδιορρυθμία της Python είναι ότι -- αν οι δηλώσεις :keyword:`global` ή :keyword:"
"`nonlocal` δεν είναι σε ισχύ -- οι εκχωρήσεις στα ονόματα πηγαίνουν πάντα στην "
"ενδότερη εμβέλεια. Οι εκχωρήσεις δεν αντιγράφουν δεδομένα --- απλώς δεσμεύουν ονόματα σε "
"αντικείμενα. Το ίδιο ισχύει και για τις διαγραφές: η δήλωση `del x` αφαιρεί "
"την σύνδεση του ``x`` από τον χώρο ονομάτων που αναφέρεται από την τοπική εμβέλεια. Στην "
"πραγματικότητα, όλες οι λειτουργίες που εισάγουν νέα ονόματα χρησιμοποιούν την τοπική εμβέλεια: συγκεκριμένα "
"οι δηλώσεις, :keyword:`import` και οι ορισμοί συναρτήσεων δεσμεύουν το "
"όνομα του module ή της συνάρτησης στην τοπική εμβέλεια."

#: tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"Η δήλωση :keyword:`global` μπορεί να χρησιμοποιηθεί για να υποδείξει ότι συγκεκριμένες "
"μεταβλητές ζουν στην καθολική εμβέλεια και θα πρέπει να ανακάμψουν εκεί. Η δήλωση :keyword:"
"`nonlocal` υποδηλώνει ότι συγκεκριμένες μεταβλητές ζουν σε μια "
"εσώκλειστη εμβέλεια και θα πρέπει να ανακάμψουν εκεί."

#: tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Παράδειγμα Εμβέλειας και Χώρων Ονομάτων"

#: tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Αυτό είναι ένα παράδειγμα που δείχνει τον τρόπο αναφοράς στα διαφορετικά πεδία και "
"χώρους ονομάτων και πώς τα :keyword:`global` και :keyword:`nonlocal` επηρεάζουν τα "
"variable binding::"

#: tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "Το αποτέλεσμα του κώδικα στο παράδειγμα είναι:"

#: tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Σημειώστε πώς η εκχώρηση *τοπική* (η οποία είναι προεπιλεγμένη) δεν άλλαξε "
"την δέσμευση *scope_test*\\'s  του *spam*. Η εκχώρηση :keyword:`nonlocal` "
"άλλαξε την δέσμευση του *scope_test*\\'s του *spam* και η εκχώρηση του :keyword:`global` "
"άλλαξε τη δέσμευση σε επίπεδο module."

#: tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Μπορείτε επίσης να δείτε ότι δεν υπήρχε προηγούμενη δέσμευση για *spam* πριν από την εκχώρηση :"
"keyword:`global`"

#: tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Μια πρώτη ματιά στις Κλάσεις"

#: tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Οι Κλάσεις εισάγουν λίγη νέα σύνταξη, τρεις νέους τύπους αντικειμένων και κάποια νέα σημασιολογία."

#: tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Σύνταξη Ορισμού Κλάσης"

#: tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "Η απλούστερη μορφή ορισμού κλάσης μοιάζει με αυτό::"

#: tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Ορισμοί κλάσεων, όπως ορισμοί συναρτήσεων (:keyword:`def` δηλώσεις) "
"πρέπει να εκτελεστούν προτού έχουν οποιοδήποτε αποτέλεσμα. (Θα μπορούσατε να τοποθετήσετε "
"έναν ορισμό κλάσης σε έναν κλάδο μιας δήλωσης :keyword:`if` ή μέσα σε μια "
"συνάρτηση.)"

#: tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Στην πράξη, οι δηλώσεις μέσα σε έναν ορισμό κλάσης συνήθως θα είναι "
"ορισμοί συναρτήσεων, αλλά επιτρέπονται άλλες δηλώσεις και μερικές φορές χρήσιμες "
"--- θα επανέλθουμε σε αυτό αργότερα. Οι ορισμοί συναρτήσεων μέσα σε μια κλάση "
"συνήθως έχουν μια περίεργη μορφή λίστας ορισμάτων, που υπαγορεύεται από τις συμβάσεις "
"κλήσης για μεθόδους --- και πάλι, αυτό εξηγείται αργότερα."

#: tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Όταν εισάγεται ένας ορισμός κλάσης, δημιουργείται ένας νέος χώρος ονομάτων και χρησιμοποιείται ως "
"τοπική εμβέλεια --- επομένως, όλες οι εκχωρήσεις σε τοπικές μεταβλητές πηγαίνουν σε αυτόν "
"τον νέο χώρο ονομάτων. Συγκεκριμένα, οι ορισμοί συναρτήσεων δεσμεύουν το όνομα της νέας "
"συνάρτησης εδώ."

#: tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"Όταν ένας ορισμός κλάσης αφήνεται κανονικά (μέσω του τέλους),δημιουργείται ένα *αντικείμενο κλάσης*. "
"Αυτό είναι βασικά ένα περιτύλιγμα γύρω από τα περιεχόμενα του χώρου ονομάτων "
"που δημιουργήθηκε από τον ορισμό κλάσης. θα μάθουμε περισσότερα για τα αντικείμενα κλάσης στην "
"επόμενη ενότητα.Η αρχική τοπική εμβέλεια(αυτό που ίσχυε λίγο πριν από την "
"εισαγωγή του ορισμού της κλάσης) αποκαθίσταται και το αντικείμενο κλάσης δεσμεύεται εδώ "
"στο όνομα κλάσης που δίνεται στην κεφαλίδα ορισμού κλάσης (:class:`!"
"ClassName` στο παράδειγμα)."

#: tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Αντικείμενα Κλάσης"

#: tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Τα αντικείμενα κλάσης υποστηρίζουν δύο είδη πράξεων: αναφορές χαρακτηριστικών και στιγμιότυπο."

#: tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"Οι *Αναφορές χαρακτηριστικών* χρησιμοποιούν την τυπική σύνταξη που χρησιμοποιείται για όλα τις αναφορές χαρακτηριστικών "
"στην Python: ``obj.name``. Τα έγκυρα ονόματα χαρακτηριστικών είναι όλα τα ονόματα "
"που βρίσκονταν στον χώρο ονομάτων της κλάσης όταν δημιουργήθηκε το αντικείμενο της κλάσης. Έτσι, "
"αν ο ορισμός της κλάσης έμοιαζε ως εξής::"

#: tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`!__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"τότε τα `MyClass.i` και `MyClass.f` είναι έγκυρες αναφορές χαρακτηριστικών, "
"επιστρέφοντας έναν ακέραιο και ένα αντικείμενο συνάρτησης, αντίστοιχα.Τα attributes κλάσης "
"μπορούν επίσης να εκχωρηθούν, ώστε να μπορείτε να αλλάξετε την τιμή του `MyClass.i` "
"ανά ανάθεση. :attr:`!__doc__` είναι επίσης ένα έγκυρο χαρακτηριστικό, επιστρέφοντας το "
"docstring που ανήκει στην κλάση: ``\'Ένα απλό παράδειγμα κλάσης\'``."

#: tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Η κλάση *στιγμιότυπο* χρησιμοποιεί σημειογραφία συνάρτησης. Απλώς προσποιηθείτε ότι το "
"αντικείμενο της κλάσης είναι μια συνάρτηση χωρίς παραμέτρους που επιστρέφει ένα νέο στιγμιότυπο της κλάσης."
"Για παράδειγμα (υποθέτοντας την παραπάνω κλάση)::"

#: tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"δημιουργεί ένα νέο *στιγμιότυπο* της κλάσης και εκχωρεί αυτό το αντικείμενο στην τοπική "
"μεταβλητή ``x``."

#: tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"Η λειτουργία του στιγμιότυπου (\"calling\" ένα αντικείμενο κλάσης) δημιουργεί ένα κενό "
"αντικείμενο. Σε πολλές κλάσεις αρέσει να δημιουργούν αντικείμενα με στιγμιότυπα προσαρμοσμένα σε μια "
"συγκεκριμένη αρχική κατάσταση. Επομένως μια κλάση μπορεί να ορίσει μια ειδική μέθοδο με το όνομα :"
"meth:`~object.__init__`, όπως αυτό::"

#: tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Όταν μια κλάση ορίζει μια μέθοδο :meth:`~object.__init__`, το στιγμιότυπο κλάσης "
"καλεί αυτόματα :meth:`!__init__` για το στιγμιότυπο κλάσης που δημιουργήθηκε πρόσφατα. "
"Έτσι σε αυτό το παράδειγμα,ένα νέο, αρχικοποιημένο στιγμιότυπο μπορεί να ληφθεί "
"από::"

#: tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"Φυσικά, η μέθοδος :meth:`~object.__init__` μπορεί να έχει ορίσματα για "
"μεγαλύτερη ευελιξία. Σε αυτήν την περίπτωση, τα ορίσματα που δίνονται στον "
"τελεστή στιγμιότυπου κλάσης μεταβιβάζονται σε :meth:`!__init__`. Για παράδειγμα, ::"

#: tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Αντικείμενα Στιγμιοτύπων"

#: tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Τώρα τι μπορούμε να κάνουμε με τα αντικείμενα στιγμιοτύπων; Οι μόνες λειτουργίες που γίνονται κατανοητές από "
"τα αντικείμενα στιγμιοτύπων είναι οι αναφορές χαρακτηριστικών. Υπάρχουν δύο είδη έγκυρων "
"ονομάτων attributes: attributes και μέθοδοι δεδομένων."

#: tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*τα attributes δεδομένων* αντιστοιχούν στις \"μεταβλητές στιγμιότυπου\" στο Smalltalk και στα "
"\"μέλη δεδομένων\" στη C++. Τα attributes δεδομένων δεν χρειάζεται να δηλωθούν, όπως και οι τοπικές "
"μεταβλητές, εμφανίζονται όταν εκχωρούνται για πρώτη φορά. Για "
"παράδειγμα, εάν το ``x`` είναι στιγμιότυπο του :class:`!MyClass` που δημιουργήθηκε παραπάνω, το "
"ακόλουθο κομμάτι κώδικα θα εκτυπώσει την τιμή ``16``, χωρίς να αφήσει "
"ίχνος::"

#: tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"Το άλλο είδος αναφοράς χαρακτηριστικού στιγμιότυπου είναι μια *μέθοδος*. Μια μέθοδος είναι μια "
"συνάρτηση που \"ανήκει\" σε ένα αντικείμενο. (Στην Python, ο όρος μέθοδος δεν είναι "
"μοναδικός σε στιγμιότυπα κλάσεων: άλλοι τύποι αντικειμένων μπορούν επίσης να έχουν μεθόδους. Για "
"παράδειγμα, τα αντικείμενα λίστας έχουν μεθόδους που ονομάζονται προσάρτηση(append), εισαγωγή(insert), αφαίρεση(remove), ταξινόμηση(sort) και "
"ούτω καθεξής. Ωστόσο, στην παρακάτω συζήτηση, θα χρησιμοποιήσουμε τον όρο μέθοδος "
"αποκλειστικά για να εννοούμε μεθόδους αντικειμένων στιγμιότυπου κλάσης, εκτός εάν ρητά "
"δηλώνεται διαφορετικά.)"

#: tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Τα έγκυρα ονόματα μεθόδων ενός αντικειμένου στιγμιότυπου εξαρτώνται από την κλάση του. Εξ "
"ορισμού, όλα τα χαρακτηριστικά μιας κλάσης που είναι αντικείμενα συνάρτησης ορίζουν τις "
"αντίστοιχες μεθόδους των στιγμιοτύπων της. Έτσι στο παράδειγμά μας, το `x.f` είναι μια "
"έγκυρη αναφορά μεθόδου, αφού το `MyClass.f` είναι συνάρτηση, αλλά το `x.i` δεν είναι "
"αφού το `MyClass.i` δεν είναι. Αλλά το `x.f` δεν είναι το ίδιο πράγμα με το "
"`MyClass.f` --- είναι ένα *αντικείμενο μεθόδου*, όχι ένα αντικείμενο συνάρτησης."

#: tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Αντικείμενα Μεθόδου"

#: tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Συνήθως, μια μέθοδος καλείται αμέσως μετά τη δέσμευσή της::"

#: tutorial/classes.rst:366
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"Στο παράδειγμα :class:`!MyClass`, αυτό θα επιστρέψει τη συμβολοσειρά ``'hello "
"world'``. Ωστόσο, δεν είναι απαραίτητο να καλέσετε μια μέθοδο αμέσως: το ``x.f`` "
"είναι ένα αντικείμενο μεθόδου και μπορεί να αποθηκευτεί και να κληθεί αργότερα. Για "
"παράδειγμα::"

#: tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "θα συνεχίσει να εκτυπώνει το ``hello world`` μέχρι το τέλος του χρόνου."

#: tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Τι ακριβώς συμβαίνει όταν καλείται μια μέθοδος; Ίσως έχετε παρατηρήσει ότι ``x.f()`` "
"κλήθηκε χωρίς όρισμα παραπάνω, παρόλο που ο ορισμός της συνάρτησης "
"για :meth:`!f` καθόριζε ένα όρισμα. Τι συνέβη με το "
"όρισμα; Σίγουρα η Python δημιουργεί μια εξαίρεση όταν μια συνάρτηση που απαιτεί "
"όρισμα καλείται χωρίς --- ακόμα κι αν το όρισμα δεν χρησιμοποιείται στην πραγματικότητα "

#: tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Στην πραγματικότητα, μπορεί να έχετε μαντέψει την απάντηση: το ιδιαίτερο με τις μεθόδους "
"είναι ότι το αντικείμενο του στιγμιότυπου μεταβιβάζεται ως το πρώτο όρισμα της "
"συνάρτησης. Στο παράδειγμά μας, η κλήση ``x.f()`` είναι ακριβώς ισοδύναμη με το "
"``MyClass.f(x)``. Γενικά, η κλήση μιας μεθόδου με μια λίστα από *n* ορίσματα "
"ισοδυναμεί με την κλήση της αντίστοιχης συνάρτησης με μια λίστα ορισμάτων "
"που δημιουργείται με την εισαγωγή του αντικειμένου στιγμιότυπου της μεθόδου πριν από το πρώτο "
"όρισμα."

#: tutorial/classes.rst:389
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"Γενικά, οι μέθοδοι λειτουργούν ως εξής. Όταν γίνεται αναφορά σε ένα χαρακτηριστικό μη δεδομένων ενός "
"στιγμιότυπου, γίνεται η αναζήτηση της κλάσης του στιγμιότυπου. Εάν το όνομα υποδηλώνει "
"ένα έγκυρο χαρακτηριστικό κλάσης που είναι αντικείμενο συνάρτησης, οι αναφορές τόσο στο "
"αντικείμενο στιγμιότυπου όσο και στο αντικείμενο συνάρτησης συσκευάζονται σε ένα "
"αντικείμενο μεθόδου. Όταν το αντικείμενο της μεθόδου καλείται με μια λίστα ορισμάτων,δημιουργείται μια νέα "
"λίστα ορισμάτων από το αντικείμενο στιγμιότυπου και τη λίστα ορισμάτων, "
"και το αντικείμενο συνάρτησης καλείται με αυτήν τη νέα λίστα ορισμάτων."

#: tutorial/classes.rst:402
msgid "Class and Instance Variables"
msgstr "Μεταβλητές Κλάσης και Στιγμιότυπου"

#: tutorial/classes.rst:404
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Σε γενικές γραμμές, οι μεταβλητές στιγμιότυπου προορίζονται για δεδομένα μοναδικά για κάθε στιγμιότυπο "
"και οι μεταβλητές κλάσης είναι για χαρακτηριστικά και μεθόδους που μοιράζονται όλα τα στιγμιότυπα "
"της κλάσης::"

#: tutorial/classes.rst:426
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Όπως συζητήθηκε στο :ref:`tut-object`, τα κοινά δεδομένα μπορεί να έχουν πιθανώς εκπληκτικά "
"αποτελέσματα με τη συμμετοχή αντικειμένων :term:`mutable`  όπως λίστες και "
"λεξικά. Για παράδειγμα, η λίστα *tricks* στον παρακάτω κώδικα δεν θα πρέπει να "
"χρησιμοποιείται ως μεταβλητή κλάσης επειδή μόνο μία λίστα θα μπορούσε να είναι κοινή "
"σε όλα τα στιγμιότυπα *Dog*::"

#: tutorial/classes.rst:449
msgid "Correct design of the class should use an instance variable instead::"
msgstr "Ο σωστός σχεδιασμός της κλάσης θα πρέπει να χρησιμοποιεί μια μεταβλητή στιγμιότυπου αντί::"

#: tutorial/classes.rst:473
msgid "Random Remarks"
msgstr "Τυχαίες Παρατηρήσεις"

#: tutorial/classes.rst:477
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Αν το ίδιο όνομα χαρακτηριστικού εμφανίζεται και σε ένα στιγμιότυπο και σε μια κλάση, τότε "
"η αναζήτηση χαρακτηριστικών δίνει προτεραιότητα στο στιγμιότυπο::"

#: tutorial/classes.rst:492
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Τα χαρακτηριστικά δεδομένων μπορούν να αναφέρονται με μεθόδους καθώς και από απλούς χρήστες "
"(\"πελάτες\") ενός αντικειμένου. Με άλλα λόγια, οι κλάσεις δεν μπορούν να χρησιμοποιηθούν για την "
"υλοποίηση καθαρών αφηρημένων τύπων δεδομένων. Στην πραγματικότητα, τίποτα στην Python δεν καθιστά "
"δυνατή την επιβολή της απόκρυψης δεδομένων --- όλα βασίζονται σε σύμβαση. "
"(από την άλλη πλευρά, η εφαρμογή Python, γραμμένη σε C, μπορεί να αποκρύψει εντελώς "
"τις λεπτομέρειες υλοποίησης και να ελέγξει την πρόσβαση σε ένα αντικείμενο εάν είναι απαραίτητο "
"αυτό μπορεί να χρησιμοποιηθεί από επεκτάσεις στην Python γραμμένες σε C.)"

#: tutorial/classes.rst:500
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Οι χρήστες θα πρέπει να χρησιμοποιούν τα χαρακτηριστικά δεδομένων με προσοχή --- οι χρήστες ενδέχεται να μπερδέψουν "
"τα αμετάβλητα που διατηρούνται από τις μεθόδους σφραγίζοντας τα χαρακτηριστικά των δεδομένων τους. "
"Λάβετε υπόψη ότι οι χρήστες μπορούν να προσθέσουν δικά τους χαρακτηριστικά δεδομένων σε ένα αντικείμενο στιγμιότυπου "
"χωρίς να επηρεάσουν την εγκυρότητα των μεθόδων, εφόσον αποφεύγονται οι συγκρούσεις ονομάτων "
"--- και πάλι, μια σύμβαση ονομασίας μπορεί να σώσει πολλούς πονοκεφάλους εδώ."

#: tutorial/classes.rst:506
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Δεν υπάρχει συντομογραφία για την αναφορά χαρακτηριστικών δεδομένων (ή άλλων μεθόδων!) "
"μέσα από τις μεθόδους. Διαπιστώνω ότι αυτό στην πραγματικότητα αυξάνει  την αναγνωσιμότητα των "
"μεθόδων: δεν υπάρχει καμία πιθανότητα σύγχυσης τοπικών μεταβλητών και των μεταβλητών παραδείγματος "
"όταν εξετάζουμε μια μέθοδο."

#: tutorial/classes.rst:511
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Συχνά, το πρώτο όρισμα μιας μεθόδου ονομάζεται `self`. Αυτό δεν είναι τίποτα "
"περισσότερο από μια σύμβαση: το όνομα `self` δεν έχει καμία απολύτως ιδιαίτερη σημασία "
"για την Python. Σημειώστε, ωστόσο, ότι αν δεν ακολουθήσετε τη σύμβαση ο κώδικάς σας "
"μπορεί να είναι λιγότερο ευανάγνωστος σε άλλους προγραμματιστές Python, και είναι επίσης κατανοητό "
"ότι μπορεί να γραφτεί ένα πρόγραμμα *class browser* που να βασίζεται σε μια τέτοια "
"σύμβαση."

#: tutorial/classes.rst:517
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Κάθε αντικείμενο συνάρτησης που είναι χαρακτηριστικό κλάσης ορίζει μια μέθοδο για στιγμιότυπα "
"αυτής της κλάσης. Δεν είναι απαραίτητο ο ορισμός της συνάρτησης να "
"περικλείεται με κείμενο στον ορισμό της κλάσης: η αντιστοίχηση ενός αντικειμένου συνάρτησης σε μια "
"τοπική μεταβλητή της κλάσης είναι επίσης εντάξει. Για παράδειγμα::"

#: tutorial/classes.rst:534
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"Τώρα τα ``f``, ``g`` και ``h`` είναι όλα χαρακτηριστικά της κλάσης :class:`!C` που "
"αναφέρονται σε αντικείμενα συνάρτησης, και κατά συνέπεια είναι όλες μέθοδοι "
"στιγμιοτύπων του :class:`!C` --- Το ``h`` είναι ακριβώς ισοδύναμο με το ``g``. Σημειώστε "
"ότι αυτή η πρακτική συνήθως χρησιμεύει μόνο για να μπερδέψει τον αναγνώστη ενός προγράμματος. "

#: tutorial/classes.rst:539
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Οι μέθοδοι μπορούν να καλούν άλλες μεθόδους χρησιμοποιώντας χαρακτηριστικά μεθόδου του argument `self`:: "

#: tutorial/classes.rst:553
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Οι μέθοδοι μπορεί να αναφέρονται σε καθολικά ονόματα με τον ίδιο τρόπο όπως οι συνηθισμένες συναρτήσεις."
"Η καθολική εμβέλεια που σχετίζεται με μια μέθοδο είναι το module που περιέχει "
"τον ορισμό της. (Μια κλάση δεν χρησιμοποιείται ποτέ ως καθολική εμβέλεια.) Αν και σπάνια "
"συναντά κανείς έναν καλό λόγο για τη χρήση καθολικών δεδομένων σε μια μέθοδο, υπάρχουν πολλές "
"Νόμιμες χρήσεις της καθολικής εμβέλειας: για ένα πράγμα, οι λειτουργίες και οι λειτουργικές μονάδες "
"που εισάγονται στην καθολική εμβέλεια μπορούν να χρησιμοποιηθούν από μεθόδους, καθώς και συναρτήσεις "
"και κλάσεις που ορίζονται σε αυτό. Συνήθως, η κλάση που περιέχει τη μέθοδο "
"ορίζεται από μόνη της σε αυτή την καθολική εμβέλεια, και στην επόμενη ενότητα θα βρούμε μερικούς "
"καλούς λόγους για τους οποίους μια μέθοδος θα ήθελε να αναφέρει τη δική της κλάση."

#: tutorial/classes.rst:563
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Κάθε τιμή είναι ένα αντικείμενο και επομένως έχει μια *κλάση* (ονομάζεται επίσης *τύπος* της). Αποθηκεύεται ως ``object.__class__``. "

#: tutorial/classes.rst:570
msgid "Inheritance"
msgstr "Κληρονομικότητα"

#: tutorial/classes.rst:572
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Φυσικά, ένα χαρακτηριστικό γλώσσας δεν θα ήταν αντάξιο του ονόματος \"class\" "
"χωρίς την υποστήριξη της κληρονομικότητας. Η σύνταξη για έναν παραγόμενο ορισμό κλάσης "
"μοιάζει με αυτό:"

#: tutorial/classes.rst:583
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"Το όνομα :class:`!BaseClassName` πρέπει να οριστεί σε έναν χώρο ονομάτων προσβάσιμο "
"από το πεδίο που περιέχει τον παραγόμενο ορισμό κλάσης. Στη θέση ενός ονόματος βασικής "
"κλάσης, επιτρέπονται και άλλες αυθαίρετες εκφράσεις. Αυτό μπορεί να είναι "
"χρήσιμο, για παράδειγμα, όταν η βασική κλάση ορίζεται σε άλλη module::"

#: tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"Η εκτέλεση ενός παραγόμενου ορισμού κλάσης προχωρά το ίδιο όπως για μια βασική "
"κλάση. Όταν το αντικείμενο της κλάσης κατασκευάζεται, η βασική κλάση απομνημονεύεται."
"Αυτό χρησιμοποιείται για την επίλυση αναφορών χαρακτηριστικών: εάν ένα ζητούμενο χαρακτηριστικό "
"δεν βρεθεί στην κλάση, η αναζήτηση προχωρά στην αναζήτηση στη βασική κλάση. Αυτός "
"ο κανόνας εφαρμόζεται αναδρομικά εάν η ίδια η βασική κλάση προέρχεται από κάποια "
"άλλη κλάση."

#: tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Δεν υπάρχει τίποτα το ιδιαίτερο σχετικά με την δημιουργία στιγμιότυπου παραγόμενων κλάσεων: "
"``DerivedClassName()`` δημιουργεί ένα νέο στιγμιότυπο της κλάσης. Οι αναφορές "
"μεθόδων επιλύονται ως εξής: γίνεται αναζήτηση του αντίστοιχου χαρακτηριστικού κλάσης, "
"κατεβαίνοντας προς τα κάτω στην αλυσίδα των βασικών κλάσεων εάν είναι απαραίτητο, και "
"η αναφορά της μεθόδου είναι έγκυρη εάν αυτό αποδίδει ένα αντικείμενο συνάρτησης."

#: tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Οι παράγωγες κλάσεις ενδέχεται να παρακάμπτουν τις μεθόδους των βασικών τους κλάσεων. Επειδή οι μέθοδοι "
"δεν έχουν ειδικά προνόμια όταν καλούν άλλες μεθόδους του ίδιου αντικειμένου, μια "
"μέθοδος μιας βασικής κλάσης που καλεί μια άλλη μέθοδο που ορίζεται στην ίδια βασική "
"κλάση μπορεί να καταλήξει να καλεί μια μέθοδο μιας παραγόμενης κλάσης που την αντικαθιστά."
"(Για προγραμματιστές C++: όλες οι μέθοδοι στην Python είναι ουσιαστικά «εικονικές».)"

#: tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Μια υπερισχύουσα μέθοδος σε μια παραγόμενη κλάση μπορεί στην πραγματικότητα να θέλει να επεκτείνει αντί "
"να αντικαταστήσει απλώς τη μέθοδο βασικής κλάσης με το ίδιο όνομα. Υπάρχει ένας "
"απλός τρόπος για να καλέσετε τη μέθοδο βασικής κλάσης απευθείας: απλώς καλέστε το "
"``BaseClassName.methodname(self, arguments)`. Αυτό είναι περιστασιακά χρήσιμο στους χρήστες "
"(Λάβετε υπόψη ότι αυτό λειτουργεί μόνο εάν η βασική κλάση είναι προσβάσιμη ως "
"``BaseClassName`` στην καθολική εμβέλεια.)"

#: tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Η Python έχει δύο (ενσωματωμένες) built-in συναρτήσεις που λειτουργούν με κληρονομικότητα:"

#: tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Χρησιμοποιήστε το :func:`isinstance` για να ελέγξετε τον τύπο ενός στιγμιότυπου: το ``isinstance(obj, int)`` "
"θα είναι ``True`` μόνο εάν το ``obj.__class__`` είναι :class:`int` ή προέρχεται από κάποια κλάση "
"από :class:`int`."

#: tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Χρησιμοποιήστε το :func:`issubclass` για να ελέγξετε την κληρονομικότητα κλάσης: Το ``issubclass(bool, int)`` "
"είναι `` True`` αφού το :class:`bool` είναι υποκλάση του :class:`int`. Ωστόσο, το "
"``issubclass(float, int)`` είναι ``False`` αφού το :class:`float` δεν είναι "
"υποκλάση του :class:`int`."

#: tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "Πολλαπλή Κληρονομικότητα"

#: tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Η Python υποστηρίζει επίσης μια μορφή πολλαπλής κληρονομικότητας. Ένας ορισμός κλάσης "
"με πολλαπλές βασικές κλάσεις μοιάζει με αυτό::"

#: tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"Για τους περισσότερους σκοπούς, στις πιο απλές περιπτώσεις, μπορείτε να σκεφτείτε την αναζήτηση "
"χαρακτηριστικών που κληρονομήθηκαν από μια γονική κλάση ως depth-first, από αριστερά προς τα δεξιά, "
"χωρίς αναζήτηση δύο φορές στην ίδια κλάση όπου υπάρχει επικάλυψη στην "
"ιεραρχία. Έτσι, εάν δεν βρεθεί ένα χαρακτηριστικό στο :class:`!DerivedClassName`, "
"αναζητείται στο :class:`!Base1` και μετά (αναδρομικά) στις βασικές "
"κλάσεις του :class:`!Base1`, και αν δεν βρέθηκε εκεί,αναζητήθηκε στο "
":class:`!Base2`, και ούτω καθεξής."

#: tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"Στην πραγματικότητα, είναι λίγο πιο περίπλοκο από αυτό. Η σειρά ανάλυσης της μεθόδου "
"αλλάζει δυναμικά για να υποστηρίξει συνεργατικές κλήσεις σε :func:`super`. Αυτή "
"η προσέγγιση είναι γνωστή σε ορισμένες άλλες γλώσσες πολλαπλής κληρονομικότητας ως call-next-method "
"και είναι πιο ισχυρή από τη σούπερ κλήση που βρίσκεται σε γλώσσες μεμονωμένης κληρονομικότητας."

#: tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""
"Η δυναμική σειρά είναι απαραίτητη επειδή όλες οι περιπτώσεις πολλαπλής κληρονομικότητας "
"εμφανίζουν μία ή περισσότερες σχέσεις διαμαντιών (όπου τουλάχιστον μια από τις γονικές "
"κλάσεις μπορεί να προσπελαστεί μέσω πολλαπλών διαδρομών από την κατώτατη κλάση). "
"Για παράδειγμα, όλες οι κλάσεις κληρονομούν από :class:`object`, επομένως κάθε περίπτωση "
"πολλαπλής κληρονομικότητας παρέχει περισσότερες από μία διαδρομές για να φτάσετε στο :class:`object`. "
"Για να μην υπάρχει πρόσβαση στις βασικές κλάσεις περισσότερες από μία φορές, ο δυναμικός "
"αλγόριθμος γραμμικοποιεί τη σειρά αναζήτησης με τρόπο που διατηρεί τη σειρά από αριστερά προς τα δεξιά-"
"που καθορίζεται σε κάθε κλάση, που καλεί κάθε γονέα μόνο μία φορά, "
"και που είναι μονότονος (που σημαίνει ότι μια κλάση μπορεί να γίνει υπό-κλάση χωρίς "
"να επηρεαστεί η σειρά προτεραιότητας των γονέων της). Συνολικά, αυτές "
"οι ιδιότητες καθιστούν δυνατό τον σχεδιασμό αξιόπιστων και επεκτάσιμων κλάσεων με "
"πολλαπλή κληρονομικότητα. Για περισσότερες λεπτομέρειες, ανατρέξτε στη διεύθυνση https://www.python.org/download/"
"releases/2.3/mro/."

#: tutorial/classes.rst:674
msgid "Private Variables"
msgstr "Ιδιωτικές Μεταβλητές"

#: tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Οι μεταβλητές στιγμιοτύπου \"Private\" στις οποίες δεν είναι δυνατή η πρόσβαση εκτός από το εσωτερικό ενός "
"αντικειμένου,δεν υπάρχουν στην Python. Ωστόσο, υπάρχει μια σύμβαση που ακολουθείται "
"από τον περισσότερο Python κώδικα: ένα όνομα με πρόθεμα κάτω παύλα (π.χ. "
"``_spam``) θα πρέπει να αντιμετωπίζεται ως μη δημόσιο μέρος του API "
"(είτε πρόκειται για συνάρτηση,μέθοδο ή μέλος δεδομένων). Θα πρέπει να θεωρείται ως "
"λεπτομέρεια υλοποίησης και υπόκειται σε αλλαγές χωρίς προειδοποίηση. "

#: tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Δεδομένου ότι υπάρχει μια έγκυρη περίπτωση χρήσης για ιδιωτικά μέλη της κλάσης (δηλαδή για να αποφευχθούν "
"συγκρούσεις ονομάτων με ονόματα που ορίζονται από υποκλάσεις), υπάρχει περιορισμένη "
"υποστήριξη για έναν τέτοιο μηχανισμό, που ονομάζεται :dfn:`name mangling`. Οποιοδήποτε αναγνωριστικό "
"της φόρμας ``__spam`` (τουλάχιστον δύο προπορευόμενες κάτω παύλες, το πολύ μια "
"στη συνέχεια κάτω παύλα) αντικαθίσταται με κείμενο με το ``_classname__spam``, όπου το "
"``classname`` είναι το όνομα της τρέχουσας τάξης με την πρώτη υπογράμμιση "
"stripped. Αυτό το mangling γίνεται χωρίς να λαμβάνεται υπόψη η συντακτική θέση του "
"του αναγνωριστικού, αρκεί να εμφανίζεται εντός του ορισμού μιας κλάσης."

#: tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Η παραβίαση ονομάτων είναι χρήσιμη για να επιτρέπεται στις υποκλάσεις να παρακάμπτουν μεθόδους χωρίς "
"να διακόπτουν τις κλήσεις μεθόδων ενδοκλάσεων. Για παράδειγμα::"

#: tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"Το παραπάνω παράδειγμα θα λειτουργούσε ακόμα και αν το ``MappingSubclass`` εισήγαγε ένα "
"αναγνωριστικό ``__update`` αφού αντικαταστάθηκε με το ``_Mapping__update`` στην "
"κλάση ``Mapping`` και με το ``_MappingSubclass__update`` στη "
"κλάση ``MappingSubclass`` αντίστοιχα."

#: tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Λάβετε υπόψη ότι οι κανόνες παραβίασης έχουν σχεδιαστεί κυρίως για την αποφυγή ατυχημάτων.Εξακολουθεί "
"να είναι δυνατή η πρόσβαση ή η τροποποίηση μιας μεταβλητής που θεωρείται "
"ιδιωτική. Αυτό μπορεί να είναι χρήσιμο ακόμη και σε ειδικές περιπτώσεις, όπως στο "
"πρόγραμμα εντοπισμού σφαλμάτων(debugger)."

#: tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Σημειώστε ότι ο κώδικας που μεταβιβάστηκε στο ``exec()`` ή στο ``eval()`` δεν θεωρεί ότι το "
"το όνομα κλάσης της κλάσης επίκλησης να είναι η τρέχουσα κλάση. Αυτό είναι παρόμοιο με "
"το αποτέλεσμα της ``καθολικής`` δήλωσης , το αποτέλεσμα της οποίας επίσης "
"περιορίζεται στον κώδικα που έχει μεταγλωττιστεί μαζί(byte-compiled). Ο ίδιος περιορισμός "
"ισχύει για τα ``getattr()``, ``setattr()`` και ``delattr()``, καθώς και όταν γίνεται "
"αναφορά απευθείας στο ``__dict__``."

#: tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Μικροπράγματα"

#: tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"Μερικές φορές είναι χρήσιμο να έχετε έναν τύπο δεδομένων παρόμοιο με τον Pascal \"record\" "
"ή C \"struct\", ομαδοποιώντας μερικά επώνυμα στοιχεία δεδομένων. Η ιδιωματική "
"προσέγγιση είναι η χρήση :mod:`dataclasses` για αυτόν τον σκοπό::"

#: tutorial/classes.rst:759
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"Ένα κομμάτι κώδικα Python που αναμένει έναν συγκεκριμένο αφηρημένο τύπο δεδομένων μπορεί "
"συχνά να περάσει σε μια κλάση που μιμείται τις μεθόδους αυτού του τύπου δεδομένων. "
"Για παράδειγμα, εάν έχετε μια συνάρτηση που μορφοποιεί ορισμένα δεδομένα από ένα "
"αντικείμενο αρχείου, μπορείτε να ορίσετε μια κλάση με μεθόδους :meth:`~io.TextIOBase.read` "
"και :meth:`~io.TextIOBase.readline` που λαμβάνουν τα δεδομένα από ένα buffer συμβολοσειρών "
"αντ' αυτού, και περάστε το ως όρισμα."

#: tutorial/classes.rst:771
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Instance method objects <instance-methods>` έχουν επίσης χαρακτηριστικά: :"
"attr:`m.__self__ <method.__self__>` είναι το αντικείμενο παρουσίας με τη μέθοδο :"
"meth:`!m`, και :attr:`m.__func__ <method.__func__>` είναι το :ref:`αντικείμενο συνάρτησης "
"<user-defined-funcs>` που αντιστοιχεί στη μέθοδο."

#: tutorial/classes.rst:781
msgid "Iterators"
msgstr "Επαναλήπτες"

#: tutorial/classes.rst:783
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Μέχρι τώρα πιθανότατα έχετε παρατηρήσει ότι τα περισσότερα αντικείμενα container μπορούν να επαναληφθούν "
"χρησιμοποιώντας μια δήλωση :keyword:`for`::"

#: tutorial/classes.rst:797
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Αυτό το στυλ πρόσβασης είναι σαφές, συνοπτικό και βολικό. Η χρήση των "
"Iterators διαπερνά και ενοποιεί την Python. Στο παρασκήνιο, η δήλωση :keyword:"
"`for` καλεί :func:`iter` στο αντικείμενο container. Η συνάρτηση "
"επιστρέφει ένα αντικείμενο iterator που ορίζει τη μέθοδο :meth:`~iterator."
"__next__` η οποία έχει πρόσβαση σε στοιχεία στο container ένα κάθε φορά. Όταν "
"δεν υπάρχουν άλλα στοιχεία, το :meth:`~iterator.__next__` δημιουργεί μια :exc:"
"`StopIteration` εξαίρεση που λέει τον βρόχο :keyword:`!for` να "
"τερματιστεί. Μπορείτε να καλέσετε τη μέθοδο :meth:`~iterator.__next__` χρησιμοποιώντας την "
"ενσωματωμένη συνάρτηση :func:`next`. Αυτό το παράδειγμα δείχνει πώς λειτουργούν όλα::"

#: tutorial/classes.rst:822
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"Έχοντας δει τους μηχανισμούς πίσω από το πρωτόκολλο iterator, είναι εύκολο να προσθέσετε "
"συμπεριφορά iterator στις κλάσεις σας. Ορίστε μια μέθοδο :meth:`~container.__iter__` "
"που επιστρέφει ένα αντικείμενο με μια μέθοδο :meth:`~iterator.__next__`. Εάν "
"η κλάση ορίζει :meth:`!__next__`, τότε το :meth:`!__iter__` μπορεί απλώς να επιστρέψει "
"``self``::"

#: tutorial/classes.rst:859
msgid "Generators"
msgstr "Γεννήτορες (Generators)"

#: tutorial/classes.rst:861
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` είναι ένα απλό και ισχυρό εργαλείο για τη δημιουργία "
"iterators. Είναι γραμμένες σαν κανονικές συναρτήσεις αλλά χρησιμοποιούν τη :keyword:"
"`yield` όποτε θέλουν να επιστρέψουν δεδομένα. Κάθε φορά που καλείται :func:`next` "
"σε αυτό, ο generator συνεχίζει από εκεί που σταμάτησε (θυμάται όλες τις "
"τιμές δεδομένων και ποια δήλωση εκτελέστηκε τελευταία). Ένα παράδειγμα δείχνει "
"ότι οι generators μπορεί να είναι ασήμαντα εύκολο να δημιουργηθούν::"

#: tutorial/classes.rst:882
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"Οτιδήποτε μπορεί να γίνει με generators μπορεί να γίνει και με iterators "
"που βασίζονται σε κλάσεις, όπως περιγράφεται στην προηγούμενη ενότητα. Αυτό που κάνει τους generators τόσο "
"συμπαγείς είναι ότι οι μέθοδοι :meth:`~iterator.__iter__` και "
":meth:`~.generator__next__` δημιουργούνται αυτόματα."

#: tutorial/classes.rst:887
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Ένα άλλο βασικό χαρακτηριστικό είναι ότι οι τοπικές μεταβλητές και η κατάσταση εκτέλεσης "
"αποθηκεύονται αυτόματα μεταξύ των κλήσεων. Αυτό έκανε τη συνάρτηση πιο εύκολη στην γραφή "
"και πολύ πιο ξεκάθαρη από μια προσέγγιση που χρησιμοποιεί μεταβλητές παράδειγμα όπως ``self."
"index`` και ``self.data``."

#: tutorial/classes.rst:892
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Εκτός από την αυτόματη δημιουργία μεθόδου και την αποθήκευση της κατάστασης του προγράμματος, όταν "
"οι generators τερματίζονται, εγείρουν αυτόματα την εξαίρεση :exc:`StopIteration`. "
"Σε συνδυασμό, αυτά τα χαρακτηριστικά καθιστούν εύκολη τη δημιουργία επαναλήψεων χωρίς περισσότερη "
"προσπάθεια από τη σύνταξη μιας κανονικής συνάρτησης."

#: tutorial/classes.rst:901
msgid "Generator Expressions"
msgstr "Εκφράσεις Γεννήτορων"

#: tutorial/classes.rst:903
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Ορισμένοι απλοί generators μπορούν να κωδικοποιηθούν συνοπτικά ως εκφράσεις χρησιμοποιώντας μια σύνταξη "
"παρόμοια με τις list comprehensions, αλλά με παρενθέσεις αντί για αγκύλες. "
"Αυτές οι εκφράσεις έχουν σχεδιαστεί για καταστάσεις όπου ο generator "
"χρησιμοποιείται αμέσως από μια περικλείουσα συνάρτηση. Οι εκφράσεις generator είναι πιο "
"συμπαγείς αλλά λιγότερο ευέλικτες από τους ορισμούς πλήρους generator και τείνουν να είναι "
"περισσότερο φιλικό προς τη μνήμη από αντίστοιχα list comprehensions."

#: tutorial/classes.rst:910
msgid "Examples::"
msgstr "Παραδείγματα::"

#: tutorial/classes.rst:931
msgid "Footnotes"
msgstr "Υποσημειώσεις"

#: tutorial/classes.rst:932
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Εκτός από ένα πράγμα. Τα αντικείμενα του module έχουν ένα μυστικό χαρακτηριστικό μόνο για ανάγνωση που "
"καλείται :attr:`~object.__dict__` το οποίο επιστρέφει το λεξικό που χρησιμοποιείται για την "
"υλοποίηση του χώρου ονομάτων του module.Το όνομα :attr:`~object.__dict__` είναι ένα "
"χαρακτηριστικό αλλά όχι καθολικό όνομα. Προφανώς, η χρήση αυτού παραβιάζει την "
"αφαίρεση υλοποίησης χώρου ονομάτων και θα πρέπει να περιορίζεται σε πράγματα "
"όπως τα ύστερα προγράμματα εντοπισμού σφαλμάτων."

#: tutorial/classes.rst:347
msgid "object"
msgstr "αντικείμενο"

#: tutorial/classes.rst:347
msgid "method"
msgstr "μέθοδος"

#: tutorial/classes.rst:683
msgid "name"
msgstr "όνομα"

#: tutorial/classes.rst:683
msgid "mangling"
msgstr "συντριβή"
