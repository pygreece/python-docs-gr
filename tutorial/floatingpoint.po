# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-03-14 12:51+0000\n"
"PO-Revision-Date: \n"
"Last-Translator: Panagiotis Skias <panagiotis.skias@gmail.com>\n"
"Language-Team: PyGreece <pygreece@gmail.com>\n"
"Language: el\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.2\n"

#: tutorial/floatingpoint.rst:10
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Αριθμητική Κινητής Υποδιαστολής:  Ζητήματα και Περιορισμοί"

#: tutorial/floatingpoint.rst:16
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.625`` has "
"value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.101`` has value 1/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""
"Οι αριθμοί κινητής υποδιαστολής αντιπροσωπεύονται στο υλικό του υπολογιστή "
"ως κλάσματα με βάση το 2 (δυαδικά).  Για παράδειγμα, το **δεκαδικό** κλάσμα "
"``0.625`` έχει τιμή 6/10 + 2/100 + 5/1000, και με τον ίδιο τρόπο το "
"**δυαδικό** κλάσμα ``0.101`` έχει τιμή 1/2 + 0/4 + 1/8. Αυτά τα δύο κλάσματα "
"έχουν πανομοιότυπες τιμές, η μόνη πραγματική διαφορά είναι ότι το πρώτο "
"είναι γραμμένο με κλασματικό συμβολισμό με βάση το 10, και το δεύτερο με "
"βάση το 2."

#: tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Δυστυχώς, τα περισσότερα δεκαδικά κλάσματα δεν μπορούν να αναπαρασταθούν "
"ακριβώς ως κλάσματα.  Η συνέπεια είναι ότι, γενικά, οι δεκαδικοί αριθμοί "
"κινητής υποδιαστολής που εισάγετε προσεγγίζονται μόνο από τους δυαδικούς "
"αριθμούς κινητής υποδιαστολής που είναι πράγματι αποθηκευμένοι στο μηχάνημα."

#: tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Το πρόβλημα είναι πιο κατανοητό στην αρχή με βάση το 10.  Θεωρήστε το κλάσμα "
"1/3.  Μπορεί να το προσεγγίσετε ως κλάσμα βάσης 10::"

#: tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "ή, καλύτερα, ::"

#: tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"και ούτω καθεξής.  Όσα ψηφία και αν είστε διατεθειμένοι να γράψετε, το "
"αποτέλεσμα δεν θα είναι ποτέ ακριβώς το 1/3, αλλά θα είναι μια ολοένα και "
"καλύτερη προσέγγιση του 1/3."

#: tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"Με τον ίδιο τρόπο, ανεξάρτητα από το πόσα ψηφία βάσης 2 είστε διατεθειμένοι "
"να χρησιμοποιήσετε, η δεκαδική τιμή 0,1 δεν μπορεί να αναπαρασταθεί ακριβώς "
"ως κλάσμα βάση 2.  Στη βάση 2, το 1/10 είναι το κλάσμα που επαναλαμβάνεται ::"

#: tutorial/floatingpoint.rst:51
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Σταματήστε σε οποιονδήποτε πεπερασμένο αριθμό bit και λαμβάνετε μια "
"προσέγγιση.  Στις περισσότερες μηχανές σήμερα, οι floats προσεγγίζονται "
"χρησιμοποιώντας τα πρώτα 53 bit ξεκινώντας από το πιο σημαντικό bit και με "
"τον παρανομαστή ως δύναμη του δύο.  Στην περίπτωση του 1/10, το δυαδικό "
"κλάσμα είναι ``3602879701896397 / 2 ** 55`` που είναι κοντά αλλά όχι ακριβώς "
"ίσο με την πραγματική τιμή του 1/10."

#: tutorial/floatingpoint.rst:58
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display::"
msgstr ""
"Πολλοί χρήστες δεν γνωρίζουν την προσέγγιση λόγω του τρόπου με τον οποίο "
"εμφανίζονται οι τιμές.  Η Python εκτυπώνει μόνο μια δεκαδική προσέγγιση στην "
"πραγματική δεκαδική τιμή της δυαδικής προσέγγισης που είναι αποθηκευμένη από "
"το μηχάνημα.  Στα περισσότερα μηχανήματα,  αν η Python τύπωνε την πραγματική "
"δεκαδική τιμή της δυαδικής προσέγγισης που είναι αποθηκευμένη για 0,1, θα "
"πρέπει να εμφανίζει::"

#: tutorial/floatingpoint.rst:67
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead:"
msgstr ""
"Αυτά είναι περισσότερα ψηφία από όσα βρίσκουν χρήσιμα οι περισσότεροι, "
"επομένως η Python διατηρεί τον αριθμό των διαχειρίσιμων ψηφίων εμφανίζοντας "
"μια στρογγυλεμένη τιμή αντ' αυτού:"

#: tutorial/floatingpoint.rst:75
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Απλώς θυμηθείτε, παρόλο που το εκτυπωμένο αποτέλεσμα μοιάζει με την ακριβή "
"τιμή του 1/10, η πραγματική αποθηκευμένη τιμή είναι το πλησιέστερο "
"αναπαραστάσιμο δυαδικό κλάσμα."

#: tutorial/floatingpoint.rst:78
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Είναι ενδιαφέρον ότι υπάρχουν πολλοί διαφορετικοί δεκαδικοί αριθμοί που "
"μοιράζονται το ίδιο πλησιέστερο κατά προσέγγιση δυαδικό κλάσμα.  Για "
"παράδειγμα, οι αριθμοί ``0.1`` και "
"``0.1000000000000000055511151231257827021181583404541015625`` είναι όλα κατά "
"προσέγγιση με ``3602879701896397 / 2 ** 55``.  Δεδομένου ότι όλες αυτές οι "
"δεκαδικές τιμές μοιράζονται την ίδια προσέγγιση, οποιαδήποτε από αυτές θα "
"μπορούσε να εμφανιστεί διατηρώντας παράλληλα το αμετάβλητο ``eval(repr(x)) "
"== x``."

#: tutorial/floatingpoint.rst:86
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Ιστορικά, το prompt της Python και η ενσωματωμένη συνάρτηση :func:`repr` θα "
"επέλεγε αυτό με 17 σημαντικά ψηφία, ``0.10000000000000001``.   Ξεκινώντας με "
"την Python 3.1, η Python (στα περισσότερα συστήματα) είναι πλέον σε θέση να "
"επιλέξει το συντομότερο από αυτά και απλά εμφανίζει το ``0.1``."

#: tutorial/floatingpoint.rst:91
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Λάβετε υπόψη ότι αυτό είναι στην ίδια τη φύση του δυαδικού κινητής "
"υποδιαστολής: αυτό δεν είναι σφάλμα στην Python, ούτε είναι σφάλμα στον "
"κώδικα σας.  Θα δείτε το ίδιο πράγμα σε όλες τις γλώσσες που υποστηρίζουν "
"την αριθμητική κινητής υποδιαστολής του υλικού σας (αν και ορισμένες γλώσσες "
"μπορεί να μην *εμφανίζουν* τη διαφορά από προεπιλογή ή σε όλες τις "
"λειτουργίες εξόδου)."

#: tutorial/floatingpoint.rst:97
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits:"
msgstr ""
"Για πιο ευχάριστη απόδοση, μπορεί να θέλετε να χρησιμοποιήσετε μορφοποίηση "
"συμβολοσειράς για να δημιουργήσετε έναν περιορισμένο αριθμό σημαντικών "
"ψηφίων:"

#: tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"Είναι σημαντικό να συνειδητοποιήσουμε ότι αυτό είναι, με την πραγματική "
"έννοια, μια ψευδαίσθηση: απλά στρογγυλεύετε την *παρουσίαση* της πραγματικής "
"αξίας του μηχανήματος."

#: tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either:"
msgstr ""
"Μια ψευδαίσθηση μπορεί να γεννήσει μια άλλη.  Για παράδειγμα, καθώς το 0,1 "
"δεν είναι ακριβώς το 1/10, το άθροισμα τριών τιμών του 0,1 μπορεί να μην "
"αποφέρει ακριβώς 0,3:"

#: tutorial/floatingpoint.rst:122
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help:"
msgstr ""
"Επίσης, εφόσον το 0.1 δεν μπορεί να πλησιάσει την ακριβή τιμή του 1/10 και "
"το 0.3 δεν μπορεί να πλησιάσει την ακριβή τιμή του 3/10, τότε η προ-"
"στρογγυλοποίηση με τη συνάρτηση :func:`round` δεν μπορεί να βοηθήσει:"

#: tutorial/floatingpoint.rst:131
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`math.isclose` function can be useful for comparing inexact values:"
msgstr ""
"Αν και οι αριθμοί δεν μπορούν να γίνουν πιο κοντά στις προβλεπόμενες "
"ακριβείς τιμές τους, η συνάρτηση :func:`math.isclose` μπορεί να είναι "
"χρήσιμη για τη σύγκριση ανακριβών τιμών:"

#: tutorial/floatingpoint.rst:139
msgid ""
"Alternatively, the :func:`round` function can be used to compare rough "
"approximations:"
msgstr ""
"Εναλλακτικά, η συνάρτηση :func:`round` μπορεί να χρησιμοποιηθεί για τη "
"σύγκριση χονδρικών προσεγγίσεων:"

#: tutorial/floatingpoint.rst:147
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `Examples of Floating Point Problems "
"<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ for "
"a pleasant summary of how binary floating-point works and the kinds of "
"problems commonly encountered in practice.  Also see `The Perils of Floating "
"Point <http://www.indowsway.com/floatingpoint.htm>`_ for a more complete "
"account of other common surprises."
msgstr ""
"Η αριθμητική δυαδικής κινητής υποδιαστολής επιφυλάσσει πολλές εκπλήξεις όπως "
"αυτή.  Το πρόβλημα με το \"0.1\" εξηγείται λεπτομερώς παρακάτω, στην ενότητα "
"\"Σφάλμα Αναπαράστασης\".  Δείτε `Παραδείγματα προβλημάτων κινητής "
"υποδιαστολής <https://jvns.ca/blog/2023/01/13/examples-of-¨floating-point-"
"problems/>`_ για μια ευχάριστη περίληψη του τρόπου λειτουργίας της δυαδικής "
"κινητής υποδιαστολής και των ειδών προβλημάτων που αντιμετωπίζονται συνήθως "
"στην πράξη.  Δείτε επίσης `Οι κίνδυνοι του Floating Point <http://www."
"indowsway.com/floatingpoint.htm>`_` για μια πιο ολοκληρωμένη περιγραφή άλλων "
"κοινών εκπλήξεων."

#: tutorial/floatingpoint.rst:156
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Όπως λέει αυτό κοντά στο τέλος, \"δεν υπάρχουν εύκολες απαντήσεις.\"  "
"Ωστόσο, μην είστε υπερβολικά επιφυλακτικοί με την κινητή υποδιαστολή!  Τα "
"σφάλματα στις λειτουργίες κινητής υποδιαστολής Python κληρονομούνται από το "
"υλικό κινητής υποδιαστολής και στα περισσότερα μηχανήματα δεν είναι της "
"τάξης του 1 σε 2\\*\\*53 ανά πράξη.  Αυτό είναι παραπάνω από επαρκές για τις "
"περισσότερες εργασίες, αλλά πρέπει να έχετε κατά νου ότι δεν είναι δεκαδική "
"αριθμητική και ότι κάθε λειτουργία float μπορεί να υποστεί νέο σφάλμα "
"στρογγυλοποίησης."

#: tutorial/floatingpoint.rst:163
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Ενώ υπάρχουν παθολογικές περιπτώσεις, για την πιο περιστασιακή χρήση της "
"αριθμητικής κινητής υποδιαστολής, θα δείτε στο τέλος το αποτέλεσμα που "
"περιμένετε εάν απλώς στρογγυλοποιήσετε την εμφάνιση των τελικών "
"αποτελεσμάτων σας στον αριθμό των δεκαδικών ψηφίων που περιμένετε. Το :func:"
"`str` συνήθως αρκεί, και για καλύτερο έλεγχο δείτε τους προσδιοριστές μορφής "
"της μεθόδου :meth:`str.format` σε :ref:`formatstrings`."

#: tutorial/floatingpoint.rst:169
msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"Για περιπτώσεις χρήσης που απαιτούν ακριβή δεκαδική αναπαράσταση, δοκιμάστε "
"να χρησιμοποιήσετε το module :mod:`decimal` που εφαρμόζει δεκαδική "
"αριθμητική κατάλληλη για λογιστικές εφαρμογές και εφαρμογές υψηλής ακριβείας."

#: tutorial/floatingpoint.rst:173
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Μια άλλη μορφή ακριβούς αριθμητικής υποστηρίζεται από το module :mod:"
"`fractions`, η οποία υλοποιεί την αριθμητική με βάση τους ορθολογικούς "
"αριθμούς (έτσι οι αριθμοί όπως το 1/3 μπορούν να αναπαρασταθούν ακριβώς)."

#: tutorial/floatingpoint.rst:177
msgid ""
"If you are a heavy user of floating-point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Εάν είστε ένα εντατικός χρήστης πράξεων κινητής υποδιαστολής, θα πρέπει να "
"ρίξετε μια ματιά στο πακέτο NumPy και πολλά άλλα πακέτα για μαθηματικές και "
"στατιστικές πράξεις που παρέχονται από το project SciPy. Δείτε <https://"
"scipy.org>."

#: tutorial/floatingpoint.rst:181
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction:"
msgstr ""
"Η Python παρέχει εργαλεία που μπορεί να βοηθήσουν σε εκείνες τις σπάνιες "
"περιπτώσεις που πραγματικά θέλετε να μάθετε την ακριβή τιμή ενός float.  Η "
"μέθοδος :meth:`float.as_integer_ratio` εκφράζει την τιμή ενός float ως "
"κλάσμα:"

#: tutorial/floatingpoint.rst:192
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value:"
msgstr ""
"Δεδομένου ότι η αναλογία είναι ακριβής, μπορεί να χρησιμοποιηθεί για την "
"αναδημιουργία χωρίς απώλειες της αρχικής τιμής:"

#: tutorial/floatingpoint.rst:200
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer:"
msgstr ""
"Η μέθοδος :meth:`float.hex` εκφράζει ένα float σε δεκαεξαδικό (βάση 16), "
"δίνοντας πάλι την ακριβή τιμή που έχει αποθηκευτεί στον υπολογιστή σας:"

#: tutorial/floatingpoint.rst:208
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly:"
msgstr ""
"Αυτή η ακριβής δεκαεξαδική αναπαράσταση μπορεί να χρησιμοποιηθεί για την "
"ανακατασκευή της τιμής float ακριβώς:"

#: tutorial/floatingpoint.rst:216
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Δεδομένου ότι η αναπαράσταση είναι ακριβής, είναι χρήσιμη για την αξιόπιστη "
"μεταφορά τιμών σε διαφορετικές εκδόσεις της Python (ανεξαρτησία πλατφόρμας) "
"και την ανταλλαγή δεδομένων με άλλες γλώσσες που υποστηρίζουν την ίδια μορφή "
"(όπως Java και C99)."

#: tutorial/floatingpoint.rst:220
msgid ""
"Another helpful tool is the :func:`sum` function which helps mitigate loss-"
"of-precision during summation.  It uses extended precision for intermediate "
"rounding steps as values are added onto a running total. That can make a "
"difference in overall accuracy so that the errors do not accumulate to the "
"point where they affect the final total:"
msgstr ""
"Ένα άλλο χρήσιμο εργαλείο είναι η συνάρτηση :func:`sum` που βοηθά στον "
"μετριασμό της απώλειας ακρίβειας κατά την άθροιση. Χρησιμοποιεί εκτεταμένη "
"ακρίβεια για ενδιάμεσα βήματα στρογγυλοποίησης καθώς οι τιμές προστίθενται "
"σε ένα τρέχον σύνολο.  Αυτό μπορεί να κάνει τη διαφορά στη συνολική "
"ακρίβεια, ώστε τα σφάλματα να μην συσσωρεύονται στο σημείο που επηρεάζουν το "
"τελικό σύνολο:"

#: tutorial/floatingpoint.rst:233
msgid ""
"The :func:`math.fsum()` goes further and tracks all of the \"lost digits\" "
"as values are added onto a running total so that the result has only a "
"single rounding.  This is slower than :func:`sum` but will be more accurate "
"in uncommon cases where large magnitude inputs mostly cancel each other out "
"leaving a final sum near zero:"
msgstr ""
"Το :func:`math.fsum()` πηγαίνει πιο μακριά και παρακολουθεί όλα τα \"χαμένα "
"ψηφία\" καθώς οι τιμές προστίθενται σε ένα τρέχον σύνολο, έτσι ώστε το "
"αποτέλεσμα να έχει μόνο μία στρογγυλοποίηση.  Αυτό είναι πιο αργό από το :"
"func:`sum` αλλά θα είναι πιο ακριβές σε ασυνήθιστες περιπτώσεις όπου οι "
"είσοδοι μεγάλου μεγέθους ακυρώνουν η μία την άλλη αφήνοντας ένα τελικό "
"άθροισμα κοντά στο μηδέν:"

#: tutorial/floatingpoint.rst:260
msgid "Representation Error"
msgstr "Σφάλμα Αναπαράστασης"

#: tutorial/floatingpoint.rst:262
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"Αυτή η ενότητα εξηγεί το παράδειγμα \"0.1\" λεπτομερώς και δείχνει πώς "
"μπορείτε να εκτελέσετε μια ακριβή ανάλυση περιπτώσεων όπως αυτή μόνοι σας.  "
"Υποτίθεται ότι έχετε βασική εξοικείωση με την αναπαράσταση δυαδικής κινητής "
"υποδιαστολής."

#: tutorial/floatingpoint.rst:266
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
"Το :dfn:`Σφάλμα αναπαράστασης (Representation error)` αναφέρεται στο γεγονός "
"ότι ορισμένα (τα περισσότερα, στην πραγματικότητα) δεκαδικά κλάσματα δεν "
"μπορούν να αναπαρασταθούν ακριβώς ως δυαδικά (βάση 2) κλάσματα.  Αυτός είναι "
"ο κύριος λόγος για τον οποίο η Python (ή Perl, C, C++, Java, Fortran, και "
"πολλές άλλες) συχνά δεν εμφανίζουν τον ακριβή δεκαδικό αριθμό που περιμένετε."

#: tutorial/floatingpoint.rst:271
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction.  Since "
"at least 2000, almost all machines use IEEE 754 binary floating-point "
"arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 "
"\"double precision\" values.  IEEE 754 binary64 values contain 53 bits of "
"precision, so on input the computer strives to convert 0.1 to the closest "
"fraction it can of the form *J*/2**\\ *N* where *J* is an integer containing "
"exactly 53 bits. Rewriting ::"
msgstr ""
"Γιατί συμβαίνει αυτό;  Το 1/10 δεν μπορεί να αναπαρασταθεί ακριβώς ως "
"δυαδικό κλάσμα.  Από το 2000 τουλάχιστον, σχεδόν όλες οι μηχανές "
"χρησιμοποιούν δυαδική αριθμητική κινητής υποδιαστολής IEEE 754 και σχεδόν "
"όλες οι πλατφόρμες αντιστοιχίζουν τα Python floats σε IEEE binary64 \"διπλής "
"ακρίβειας\" τιμές. Οι τιμές του IEEE 754 binary64 περιέχουν 53 bits "
"ακρίβειας, επομένως κατά την είσοδο ο υπολογιστής προσπαθεί να μετατρέψει το "
"0,1 στο πλησιέστερο κλάσμα που μπορεί να έχει τη μορφή *J*/2**\\ *N* όπου "
"*J* είναι ένας ακέραιος που περιέχει ακριβώς 53 bits.  Ξαναγράφεται ::"

#: tutorial/floatingpoint.rst:282
msgid "as ::"
msgstr "ως ::"

#: tutorial/floatingpoint.rst:286
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56:"
msgstr ""
"και υπενθυμίζοντας ότι το *J* έχει ακριβώς 53 bits (είναι ``>= 2**52`` αλλά "
"``< 2**53``), η καλύτερη τιμή για το *N* είναι 56:"

#: tutorial/floatingpoint.rst:294
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded:"
msgstr ""
"Δηλαδή, το 56 είναι η μόνη τιμή για το *N* που αφήνει το *J* με ακριβώς 53 "
"bits.  Η καλύτερη δυνατή τιμή για το *J* είναι τότε αυτό το πηλίκο "
"στρογγυλοποιημένο:"

#: tutorial/floatingpoint.rst:303
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up:"
msgstr ""
"Δεδομένου ότι το υπόλοιπο είναι περισσότερο από το μισό του 10, η καλύτερη "
"προσέγγιση επιτυγχάνεται με στρογγυλοποίηση προς τα επάνω:"

#: tutorial/floatingpoint.rst:313
msgid ""
"Therefore the best possible approximation to 1/10 in IEEE 754 double "
"precision is::"
msgstr ""
"Ως εκ τούτου, η καλύτερη δυνατή προσέγγιση στο 1/10 στο IEEE 754 διπλής "
"ακρίβειας είναι::"

#: tutorial/floatingpoint.rst:318
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr ""
"Η διαίρεση του αριθμητή και του παρονομαστή με δύο μειώνει το κλάσμα σε::"

#: tutorial/floatingpoint.rst:322
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Λάβετε υπόψη ότι από τη στιγμή που κάναμε στρογγυλοποίηση, αυτό είναι στην "
"πραγματικότητα λίγο μεγαλύτερο από το 1/10· αν δεν είχαμε στρογγυλοποιήσει "
"προς τα πάνω, το πηλίκο θα ήταν λίγο μικρότερο από το 1/10.  Αλλά σε καμία "
"περίπτωση δεν μπορεί να είναι *ακριβώς* 1/10!"

#: tutorial/floatingpoint.rst:326
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best IEEE 754 double approximation it can get:"
msgstr ""
"Έτσι ο υπολογιστής δεν \"βλέπει\" ποτέ 1/10:  αυτό που βλέπει είναι το "
"ακριβές κλάσμα που δίνεται παραπάνω, η καλύτερη διπλή προσέγγιση IEEE 754 "
"που μπορεί να πάρει:"

#: tutorial/floatingpoint.rst:334
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits:"
msgstr ""
"Αν πολλαπλασιάσουμε αυτό το κλάσμα με 10\\*\\*55, μπορούμε να δούμε την τιμή "
"με 55 δεκαδικά ψηφία:"

#: tutorial/floatingpoint.rst:342
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits:"
msgstr ""
"που σημαίνει ότι ο ακριβής αριθμός που είναι αποθηκευμένος στον υπολογιστή "
"είναι ίσος με την δεκαδική τιμή "
"0.1000000000000000055511151231257827021181583404541015625.  Αντί να "
"εμφανιστεί η πλήρης τιμή, πολλές γλώσσες (συμπεριλαμβανομένων των "
"παλαιότερων εκδόσεων της Python), στρογγυλοποιούν το αποτέλεσμα σε 17 "
"σημαντικά ψηφία:"

#: tutorial/floatingpoint.rst:352
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations easy:"
msgstr ""
"Τα modules :mod:`fractions` και :mod:`decimal` κάνουν αυτούς τους "
"υπολογισμούς εύκολους:"
